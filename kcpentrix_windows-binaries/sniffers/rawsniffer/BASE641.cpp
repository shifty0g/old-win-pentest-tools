/*==========================================================================
   ASCII---->base64 source code
       powered by shadow
        @2004.10.4 01:01
web:http://www.codehome.6600.org
info:
     sperated by 6 bits:
-----Base64 code table:
-----0-25--> 'A"-'Z'   26-51-->'a'-'z'   52-61-->'0'-'9' 62-->'+'  63-->'/'
============================================================================*/

#include "stdafx.h"
#include "BASE641.h"



BASE64::BASE64()
{
length=0;
StrEncode=false;
StrDecode=false;
memset(Base64Str,0,1015);
base64_str=Base64Str;
fp_in=NULL;
fp_out=NULL;
Base64Error[0]="Encode Success!";
Base64Error[1]="String too long!";
Base64Error[2]="Open file failed!";
//MessageBox(NULL,"com","com",MB_OK);
}

BASE64::~BASE64()
{

}

void BASE64::put(unsigned char ch)
{
     if(ch>=0&&ch<=25) ch+=65;
     else if(ch>=26&&ch<=51) ch+=71;
     else if(ch>=52&&ch<=61) ch-=4;
     else if(ch==62) ch='+';
     else ch='/';
     if(fp_out!=NULL)
       fputc(ch,fp_out);
     //printf("%c",ch);
	 if(StrEncode) *(base64_str++)=ch;
     length++;
     if(length%76==0){
	   length=0;
	   if(fp_out!=NULL) fputs("\r\n",fp_out);
	   if(StrEncode){
         *(base64_str++)='\r';
	     *(base64_str++)='\n';
	     }
	   }
}

void BASE64::encode_1()
{
     int i;
     unsigned char ch;
     ch=code[0]>>2;
     put(ch);
     ch=(code[0]<<4)&63;
     put(ch);
     for(i=0;i<2;i++){
        if(fp_out!=NULL) fputc('=',fp_out);
        //printf("=");
	    if(StrEncode) *(base64_str++)='=';
        length++;
        if(length%76==0){
		   length=0;
		   if(fp_out!=NULL) fputs("\r\n",fp_out);
	       if(StrEncode){
              *(base64_str++)='\r';
	          *(base64_str++)='\n';
	          }
		   }
        }
}

void BASE64::encode_2()
{
     unsigned char ch;
     ch=code[0]>>2;
     put(ch);
     ch=(code[0]<<4|code[1]>>4)&63;
     put(ch);
     ch=(code[1]<<2)&63;
     put(ch);
     if(fp_out!=NULL) fputc('=',fp_out);
     //printf("=");
	 if(StrEncode) *(base64_str++)='=';
     length++;
     if(length%76==0){
	   length=0;
	   if(fp_out!=NULL) fputs("\r\n",fp_out);
	   if(StrEncode){
         *(base64_str++)='\r';
	     *(base64_str++)='\n';
	     }
	   }
}

void BASE64::encode_3()
{
     unsigned char ch;
     ch=code[0]>>2;
     put(ch);
     ch=(code[0]<<4|code[1]>>4)&63;
     put(ch);
     ch=(code[1]<<2|code[2]>>6)&63;
     put(ch);
     ch=code[2]&63;
     put(ch);
}

void BASE64::file_encode(FILE *fp)
{
     int  i=0;
     while(!feof(fp)){
          code[i]=fgetc(fp);
          if(code[i]==255&&feof(fp)) ; /*如果把文件的结尾标志-1读出来，即无符号就是255，那就不算，如果不是在文件尾就算，主要考虑到exe文件情况*/
          else i++;
          if(i==3) {encode_3();i=0;}
          }
     switch(i){
           case 1:encode_1();break;
           case 2:encode_2();break;
           default:break;
           }
}

char * BASE64::StringEncode(unsigned char *p)
{
     char base64strcopy[1015];
     if(strlen((char *)p)>MaxLen){
	   errorcode=1;
	   return NULL;
	   }   
     int i=0;
	 StrEncode=true;
	 if(StrEncode){
       while(*p){
          code[i]=*p;
          i++;
          p++;
          if(i==3) {encode_3();i=0;}
          }
       switch(i){
           case 1:encode_1();break;
           case 2:encode_2();break;
           default:break;
           }
       }
	 errorcode=0;	 
	 memset(base64strcopy,0,1015);
	 strcpy(base64strcopy,Base64Str);
//	 MessageBox(NULL,base64strcopy,"strong",MB_OK);
	 Reset();
	 return base64strcopy;
}

int BASE64::FileEncode(char *fromfile,char *tofile)
{
      fp_in=fopen(fromfile,"rb");
      fp_out=fopen(tofile,"wb+");
      if(fp_in==NULL||fp_out==NULL){
        errorcode=2;
        return errorcode;
        }
	  file_encode(fp_in);
	  errorcode=0;
	  fclose(fp_in);
	  fclose(fp_out);
	  Reset();
      return errorcode;
}

char * BASE64::GetLastError()
{
return Base64Error[errorcode];
}


void BASE64::Reset()
{
length=0;
StrEncode=false;
StrDecode=false;
memset(Base64Str,0,1015);
base64_str=Base64Str;
}
//next is base64 decode
void BASE64::decode_2()
{
     unsigned char ch;
     ch=(decode[1]<<2)|(decode[2]>>4);
     if(fp_out!=NULL) fputc(ch,fp_out);
     //printf("%c",ch);
	 if(StrDecode) *(base64_str++)=ch;
}

void BASE64::decode_3()
{
     unsigned char ch;
     ch=(decode[1]<<2)|(decode[2]>>4);
     if(fp_out!=NULL) fputc(ch,fp_out);
     //printf("%c",ch);
	 if(StrDecode) *(base64_str++)=ch;
     ch=(decode[2]<<4)|(decode[3]>>2);
     if(fp_out!=NULL) fputc(ch,fp_out);
     //printf("%c",ch);
	 if(StrDecode) *(base64_str++)=ch;
}

void BASE64::decode_4()
{
     unsigned char ch;
     ch=(decode[1]<<2)|(decode[2]>>4);
     if(fp_out!=NULL) fputc(ch,fp_out);
     //printf("%c",ch);
	 if(StrDecode) *(base64_str++)=ch;
     ch=(decode[2]<<4)|(decode[3]>>2);
     if(fp_out!=NULL) fputc(ch,fp_out);
     //printf("%c",ch);
	 if(StrDecode) *(base64_str++)=ch;
     ch=(decode[3]<<6)|decode[4];
     if(fp_out!=NULL) fputc(ch,fp_out);
     //printf("%c",ch);
	 if(StrDecode) *(base64_str++)=ch;
}

void BASE64::file_decode(FILE *fp)
{
     int i=1,j=0;
     while(!feof(fp)){
             decode[i]=fgetc(fp);
             if(decode[i]==255&&feof(fp)) ; /*如果把文件的结尾标志-1读出来，即无符号就是255，那就不算，如果不是在文件尾就算，主要考虑到exe文件情况*/
             else{
               if(decode[i]>=65&&decode[i]<=90) {decode[i]-=65;j++;}
               else if(decode[i]>=97&&decode[i]<=122) {decode[i]-=71;j++;}
               else if(decode[i]>=48&&decode[i]<=57) {decode[i]+=4;j++;}
               else if(decode[i]=='+') {decode[i]=62;j++;}
               else if(decode[i]=='/') {decode[i]=63;j++;}
               else ;
               i++;
               length++;
               if(length%76==0) fseek(fp,2L,1);
               }
             if(j==4) {decode_4();i=1;j=0;}
             }
     switch(j){
        case 2:decode_2();break;
        case 3:decode_3();break;
        default:break;
        }
}

char * BASE64::StringDecode(unsigned char *p)
{
     if(strlen((char *)p)>DeMaxLen){
	    errorcode=1;
		return NULL;
		}
     int i=1,j=0;
	 StrDecode=true;
	 if(StrDecode){
      while(*p){
	         if(*p=='\r'||*p=='\n') continue;
             decode[i]=*p;
             if(decode[i]>=65&&decode[i]<=90) {decode[i]-=65;j++;}
             else if(decode[i]>=97&&decode[i]<=122) {decode[i]-=71;j++;}
             else if(decode[i]>=48&&decode[i]<=57) {decode[i]+=4;j++;}
             else if(decode[i]=='+') {decode[i]=62;j++;}
             else if(decode[i]=='/') {decode[i]=63;j++;}
             p++;i++;
             if(j==4) {decode_4();i=1;j=0;}
        }
      switch(j){
        case 2:decode_2();break;
        case 3:decode_3();break;
        default:break;
        }
      }
	 errorcode=0;
	 char debase64str[1015];
	 strcpy(debase64str,Base64Str);
	 Reset();
	 return debase64str;
}

int BASE64::FileDecode(char *fromfile, char *tofile)
{
      fp_in=fopen(fromfile,"rb");
      fp_out=fopen(tofile,"wb+");
      if(fp_in==NULL||fp_out==NULL){
        errorcode=2;
        return errorcode;
        }
	  file_decode(fp_in);
	  errorcode=0;
	  fclose(fp_in);
	  fclose(fp_out);
	  Reset();
      return errorcode;
}
